/*! ******************************************************************************
 *
 * Pentaho Data Integration
 *
 * Copyright (C) 2002-2018 by Hitachi Vantara : http://www.pentaho.com
 *
 *******************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package org.apache.hop.pipeline.transforms.metainject;

import com.sun.corba.se.spi.ior.ObjectId;
import org.apache.hop.core.Result;
import org.apache.hop.core.RowMetaAndData;
import org.apache.hop.core.exception.HopException;
import org.apache.hop.core.exception.HopValueException;
import org.apache.hop.core.injection.Injection;
import org.apache.hop.core.injection.InjectionSupported;
import org.apache.hop.core.logging.LogChannel;
import org.apache.hop.core.logging.LogLevel;
import org.apache.hop.core.row.IValueMeta;
import org.apache.hop.core.row.RowMeta;
import org.apache.hop.core.row.value.*;
import org.apache.hop.metastore.api.IMetaStore;
import org.apache.hop.pipeline.Pipeline;
import org.apache.hop.pipeline.PipelineMeta;
import org.apache.hop.pipeline.engines.local.LocalPipelineEngine;
import org.apache.hop.pipeline.transform.BaseTransformMeta;
import org.apache.hop.pipeline.transform.ITransform;
import org.apache.hop.pipeline.transform.ITransformMeta;
import org.apache.hop.pipeline.transform.TransformMeta;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
//import org.powermock.modules.junit4.PowerMockRunner;
import org.powermock.modules.junit4.PowerMockRunner;
import org.powermock.reflect.Whitebox;

import javax.sql.RowSet;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.refEq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.anyString;

@RunWith( PowerMockRunner.class )
@PrepareForTest( { MetaInject.class } )
public class MetaInjectTest {

  private static final String INJECTOR_STEP_NAME = "TEST_STEP_FOR_INJECTION";

  private static final String TEST_VALUE = "TEST_VALUE";

  private static final String TEST_VARIABLE = "TEST_VARIABLE";

  private static final String TEST_PARAMETER = "TEST_PARAMETER";

  private static final String TEST_TARGET_STEP_NAME = "TEST_TARGET_STEP_NAME";

  private static final String TEST_SOURCE_STEP_NAME = "TEST_SOURCE_STEP_NAME";

  private static final String TEST_ATTR_VALUE = "TEST_ATTR_VALUE";

  private static final String TEST_FIELD = "TEST_FIELD";

  private static final String UNAVAILABLE_STEP = "UNAVAILABLE_STEP";

  private static final TargetStepAttribute UNAVAILABLE_TARGET_STEP =
      new TargetStepAttribute( UNAVAILABLE_STEP, TEST_ATTR_VALUE, false );

  private static final SourceStepField UNAVAILABLE_SOURCE_STEP = new SourceStepField( UNAVAILABLE_STEP, TEST_FIELD );

  private MetaInject metaInject;

  private MetaInjectMeta meta;

  private MetaInjectData data;

  private PipelineMeta transMeta;

  private Pipeline trans;

//  private StepMetaInjectionInterface metaInjectionInterface;
  private IMetaStore metaStore;

  @Before
  public void before() throws Exception {
//    repository = PowerMockito.mock( Repository.class );
    transMeta = PowerMockito.spy( new PipelineMeta() );
    meta = new MetaInjectMeta();
    data = new MetaInjectData();
    data.pipelineMeta = transMeta;
    metaInject = TransformMockUtil.getTransform( MetaInject.class, MetaInjectMeta.class, MetaInjectData.class, "MetaInjectTest" );
    metaInject = PowerMockito.spy( metaInject );
    metaInject.init();
    metaStore = mock( IMetaStore.class );
    metaInject.setMetaStore( metaStore );
    doReturn( transMeta ).when( metaInject ).getPipelineMeta();

    PipelineMeta internalTransMeta = mock( PipelineMeta.class );
    TransformMeta stepMeta = mock( TransformMeta.class );
    trans = new LocalPipelineEngine();
    trans.setLogChannel( LogChannel.GENERAL );
    trans = PowerMockito.spy( trans );
    doReturn( trans ).when( metaInject ).getPipeline();
    doReturn( INJECTOR_STEP_NAME ).when( stepMeta ).getName();
    doReturn( Collections.singletonList( stepMeta ) ).when( internalTransMeta ).getUsedTransforms();
    ITransformMeta stepMetaInterface = mock( ITransformMeta.class );
    doReturn( stepMetaInterface ).when( stepMeta ).getTransform();
//    metaInjectionInterface = mock( StepMetaInjectionInterface.class );
//    doReturn( metaInjectionInterface ).when( stepMetaInterface ).getStepMetaInjectionInterface();

    doReturn( internalTransMeta ).when( metaInject ).loadPipelineMeta();
  }

/*
  @Test
  public void injectMetaFromMultipleInputSteps() throws HopException {
    Map<TargetStepAttribute, SourceStepField> targetSourceMapping =
        new LinkedHashMap<TargetStepAttribute, SourceStepField>();
    targetSourceMapping.put( new TargetStepAttribute( INJECTOR_STEP_NAME, "DATA_TYPE", true ), new SourceStepField(
        "TYPE_INPUT", "col_type" ) );
    targetSourceMapping.put( new TargetStepAttribute( INJECTOR_STEP_NAME, "NAME", true ), new SourceStepField(
        "NAME_INPUT", "col_name" ) );
    meta.setTargetSourceMapping( targetSourceMapping );

    doReturn( new String[] { "NAME_INPUT", "TYPE_INPUT" } ).when( transMeta ).getPrevTransformNames( any( TransformMeta.class ) );

    RowSet nameInputRowSet = mock( RowSet.class );
    RowMeta nameRowMeta = new RowMeta();
    nameRowMeta.addValueMeta( new ValueMetaString( "col_name" ) );
    doReturn( nameRowMeta ).when( nameInputRowSet ).getRowMeta();
    doReturn( nameInputRowSet ).when( metaInject ).findInputRowSet( "NAME_INPUT" );

    RowSet typeInputRowSet = mock( RowSet.class );
    RowMeta typeRowMeta = new RowMeta();
    typeRowMeta.addValueMeta( new ValueMetaString( "col_type" ) );
    doReturn( typeRowMeta ).when( typeInputRowSet ).getrowMeta();
    doReturn( typeInputRowSet ).when( metaInject ).findInputRowSet( "TYPE_INPUT" );

    doReturn( new Object[] { "FIRST_NAME" } ).doReturn( null ).when( metaInject ).getRowFrom( nameInputRowSet );
    doReturn( new Object[] { "String" } ).doReturn( null ).when( metaInject ).getRowFrom( typeInputRowSet );

    List<StepInjectionMetaEntry> injectionMetaEntryList = new ArrayList<StepInjectionMetaEntry>();
    StepInjectionMetaEntry fields = new StepInjectionMetaEntry( "FIELDS", IValueMeta.TYPE_NONE, "" );
    StepInjectionMetaEntry fieldEntry = new StepInjectionMetaEntry( "FIELD", IValueMeta.TYPE_NONE, "" );
    fields.getDetails().add( fieldEntry );
    StepInjectionMetaEntry nameEntry = new StepInjectionMetaEntry( "NAME", IValueMeta.TYPE_STRING, "" );
    fieldEntry.getDetails().add( nameEntry );
    StepInjectionMetaEntry dataEntry = new StepInjectionMetaEntry( "DATA_TYPE", IValueMeta.TYPE_STRING, "" );
    fieldEntry.getDetails().add( dataEntry );
    injectionMetaEntryList.add( fields );
    doReturn( injectionMetaEntryList ).when( metaInjectionInterface ).getStepInjectionMetadataEntries();

    meta.setNoExecution( true );
    assertTrue( metaInject.init( ) );

    metaInject.processRow( );

    StepInjectionMetaEntry expectedNameEntry =
        new StepInjectionMetaEntry( "NAME", "FIRST_NAME", IValueMeta.TYPE_STRING, "" );
    StepInjectionMetaEntry expectedDataEntry =
        new StepInjectionMetaEntry( "DATA_TYPE", "String", IValueMeta.TYPE_STRING, "" );
    verify( metaInject, atLeastOnce() ).setEntryValueIfFieldExists( refEq( expectedNameEntry ), any(
        RowMetaAndData.class ), any( SourceStepField.class ) );
    verify( metaInject, atLeastOnce() ).setEntryValueIfFieldExists( refEq( expectedDataEntry ), any(
        RowMetaAndData.class ), any( SourceStepField.class ) );
  }
*/

  @Test
  public void testMetastoreIsSet() throws Exception {
    doReturn( new String[] { } ).when( transMeta ).getPrevTransformNames( any( TransformMeta.class ) );
    data.stepInjectionMetasMap = new HashMap<>();
//    data.stepInjectionMap = new HashMap<>();

    data.pipelineMeta = new PipelineMeta();

    meta.setNoExecution( false );
    doReturn( LogLevel.ERROR ).when( metaInject ).getLogLevel();
    // don't need to actually run anything to verify this. force it to "stopped"
    doReturn( true ).when( metaInject ).isStopped();
    doNothing().when( metaInject ).waitUntilFinished( any( Pipeline.class ) );
    // make sure the injected tranformation doesn't have a metastore first
    assertNull( data.pipelineMeta.getMetaStore() );

    metaInject.processRow( );

    // now it should be set
    assertEquals( metaStore, data.pipelineMeta.getMetaStore() );
  }

  @Test
  public void testTransWaitsForListenersToFinish() throws Exception {
    doReturn( new String[] { } ).when( transMeta ).getPrevTransformNames( any( TransformMeta.class ) );
    data.stepInjectionMetasMap = new HashMap<>();
//    data.stepInjectionMap = new HashMap<>();
    data.pipelineMeta = new PipelineMeta();
    meta.setNoExecution( false );
    Pipeline injectTrans = mock( Pipeline.class );
    doReturn( injectTrans ).when( metaInject ).createInjectTrans();
    when( injectTrans.isFinished() ).thenReturn( true );
    Result result = mock( Result.class );
    when( injectTrans.getResult() ).thenReturn( result );
    metaInject.processRow( );
    verify( injectTrans ).waitUntilFinished();
  }

  @Test
  public void transVariablesPassedToChildTransformation() throws HopException {
    doReturn( new String[] { TEST_VARIABLE } ).when( metaInject ).listVariables();
    doReturn( TEST_VALUE ).when( metaInject ).getVariable( TEST_VARIABLE );

    PipelineMeta transMeta = new PipelineMeta();
    doReturn( transMeta ).when( metaInject ).getPipelineMeta();
    PipelineMeta internalTransMeta = new PipelineMeta();
    doReturn( internalTransMeta ).when( metaInject ).loadPipelineMeta();

    assertTrue( metaInject.init( ) );

    assertEquals( TEST_VALUE, internalTransMeta.getVariable( TEST_VARIABLE ) );
  }

  @Test
  public void transParametersPassedToChildTransformation() throws HopException {
    Pipeline trans = new LocalPipelineEngine();
    trans.addParameterDefinition( TEST_PARAMETER, "TEST_DEF_VALUE", "" );
    trans.setParameterValue( TEST_PARAMETER, TEST_VALUE );

    doReturn( trans ).when( metaInject ).getPipeline();
    PipelineMeta internalTransMeta = new PipelineMeta();
    doReturn( internalTransMeta ).when( metaInject ).loadPipelineMeta();

    assertTrue( metaInject.init(  ) );

    assertEquals( TEST_VALUE, internalTransMeta.getParameterValue( TEST_PARAMETER ) );
  }

  @Test
  public void getUnavailableSourceSteps() {
    TargetStepAttribute targetStep = new TargetStepAttribute( TEST_TARGET_STEP_NAME, TEST_ATTR_VALUE, false );
    SourceStepField unavailableSourceStep = new SourceStepField( UNAVAILABLE_STEP, TEST_FIELD );
    Map<TargetStepAttribute, SourceStepField> targetMap = Collections.singletonMap( targetStep, unavailableSourceStep );
    PipelineMeta sourceTransMeta = mock( PipelineMeta.class );
    doReturn( new String[0] ).when( sourceTransMeta ).getPrevTransformNames( any( TransformMeta.class ) );

    Set<SourceStepField> actualSet =
        MetaInject.getUnavailableSourceSteps( targetMap, sourceTransMeta, mock( TransformMeta.class ) );
    assertTrue( actualSet.contains( unavailableSourceStep ) );
  }

  @Test
  public void getUnavailableTargetSteps() {
    TargetStepAttribute unavailableTargetStep = new TargetStepAttribute( UNAVAILABLE_STEP, TEST_ATTR_VALUE, false );
    SourceStepField sourceStep = new SourceStepField( TEST_SOURCE_STEP_NAME, TEST_FIELD );
    Map<TargetStepAttribute, SourceStepField> targetMap = Collections.singletonMap( unavailableTargetStep, sourceStep );
    PipelineMeta injectedTransMeta = mock( PipelineMeta.class );
    doReturn( Collections.emptyList() ).when( injectedTransMeta ).getUsedTransforms();

    Set<TargetStepAttribute> actualSet = MetaInject.getUnavailableTargetSteps( targetMap, injectedTransMeta );
    assertTrue( actualSet.contains( unavailableTargetStep ) );
  }

  @Test
  public void removeUnavailableStepsFromMapping_unavailable_source_step() {
    TargetStepAttribute unavailableTargetStep = new TargetStepAttribute( UNAVAILABLE_STEP, TEST_ATTR_VALUE, false );
    SourceStepField unavailableSourceStep = new SourceStepField( UNAVAILABLE_STEP, TEST_FIELD );
    Map<TargetStepAttribute, SourceStepField> targetMap = new HashMap<TargetStepAttribute, SourceStepField>();
    targetMap.put( unavailableTargetStep, unavailableSourceStep );

    Set<SourceStepField> unavailableSourceSteps = Collections.singleton( UNAVAILABLE_SOURCE_STEP );
    MetaInject.removeUnavailableStepsFromMapping( targetMap, unavailableSourceSteps, Collections
        .<TargetStepAttribute>emptySet() );
    assertTrue( targetMap.isEmpty() );
  }

  @Test
  public void removeUnavailableStepsFromMapping_unavailable_target_step() {
    TargetStepAttribute unavailableTargetStep = new TargetStepAttribute( UNAVAILABLE_STEP, TEST_ATTR_VALUE, false );
    SourceStepField unavailableSourceStep = new SourceStepField( UNAVAILABLE_STEP, TEST_FIELD );
    Map<TargetStepAttribute, SourceStepField> targetMap = new HashMap<TargetStepAttribute, SourceStepField>();
    targetMap.put( unavailableTargetStep, unavailableSourceStep );

    Set<TargetStepAttribute> unavailableTargetSteps = Collections.singleton( UNAVAILABLE_TARGET_STEP );
    MetaInject.removeUnavailableStepsFromMapping( targetMap, Collections.<SourceStepField>emptySet(),
        unavailableTargetSteps );
    assertTrue( targetMap.isEmpty() );
  }

  @Test
  public void removeUnavailableStepsFromMapping_unavailable_source_target_step() {
    TargetStepAttribute unavailableTargetStep = new TargetStepAttribute( UNAVAILABLE_STEP, TEST_ATTR_VALUE, false );
    SourceStepField unavailableSourceStep = new SourceStepField( UNAVAILABLE_STEP, TEST_FIELD );
    Map<TargetStepAttribute, SourceStepField> targetMap = new HashMap<TargetStepAttribute, SourceStepField>();
    targetMap.put( unavailableTargetStep, unavailableSourceStep );

    Set<TargetStepAttribute> unavailableTargetSteps = Collections.singleton( UNAVAILABLE_TARGET_STEP );
    Set<SourceStepField> unavailableSourceSteps = Collections.singleton( UNAVAILABLE_SOURCE_STEP );
    MetaInject.removeUnavailableStepsFromMapping( targetMap, unavailableSourceSteps, unavailableTargetSteps );
    assertTrue( targetMap.isEmpty() );
  }

/*
  @Test
  public void setEntryValue_string() throws HopValueException {
    StepInjectionMetaEntry entry = mock( StepInjectionMetaEntry.class );
    doReturn( IValueMeta.TYPE_STRING ).when( entry ).getValueType();
    RowMetaAndData row = createRowMetaAndData( new ValueMetaString( TEST_FIELD ), TEST_VALUE );
    SourceStepField sourceField = new SourceStepField( TEST_SOURCE_STEP_NAME, TEST_FIELD );

    MetaInject.setEntryValue( entry, row, sourceField );

    verify( entry ).setValue( TEST_VALUE );
  }
*/

/*
  @Test
  public void setEntryValue_boolean() throws HopValueException {
    StepInjectionMetaEntry entry = mock( StepInjectionMetaEntry.class );
    doReturn( IValueMeta.TYPE_BOOLEAN ).when( entry ).getValueType();
    RowMetaAndData row = createRowMetaAndData( new ValueMetaBoolean( TEST_FIELD ), true );
    SourceStepField sourceField = new SourceStepField( TEST_SOURCE_STEP_NAME, TEST_FIELD );

    MetaInject.setEntryValue( entry, row, sourceField );

    verify( entry ).setValue( true );
  }
*/

/*
  @Test
  public void setEntryValue_integer() throws HopValueException {
    StepInjectionMetaEntry entry = mock( StepInjectionMetaEntry.class );
    doReturn( IValueMeta.TYPE_INTEGER ).when( entry ).getValueType();
    RowMetaAndData row = createRowMetaAndData( new ValueMetaInteger( TEST_FIELD ), new Long( 1 ) );
    SourceStepField sourceField = new SourceStepField( TEST_SOURCE_STEP_NAME, TEST_FIELD );

    MetaInject.setEntryValue( entry, row, sourceField );

    verify( entry ).setValue( 1L );
  }
*/

/*
  @Test
  public void setEntryValue_number() throws HopValueException {
    StepInjectionMetaEntry entry = mock( StepInjectionMetaEntry.class );
    doReturn( IValueMeta.TYPE_NUMBER ).when( entry ).getValueType();
    RowMetaAndData row = createRowMetaAndData( new ValueMetaNumber( TEST_FIELD ), new Double( 1 ) );
    SourceStepField sourceField = new SourceStepField( TEST_SOURCE_STEP_NAME, TEST_FIELD );

    MetaInject.setEntryValue( entry, row, sourceField );

    verify( entry ).setValue( 1.0D );
  }
*/

/*
  @Test
  public void setEntryValue_date() throws HopValueException {
    StepInjectionMetaEntry entry = mock( StepInjectionMetaEntry.class );
    doReturn( IValueMeta.TYPE_DATE ).when( entry ).getValueType();
    RowMetaAndData row = createRowMetaAndData( new ValueMetaDate( TEST_FIELD ), null );
    SourceStepField sourceField = new SourceStepField( TEST_SOURCE_STEP_NAME, TEST_FIELD );

    MetaInject.setEntryValue( entry, row, sourceField );

    verify( entry ).setValue( null );
  }
*/

/*
  @Test
  public void setEntryValue_bignumber() throws HopValueException {
    StepInjectionMetaEntry entry = mock( StepInjectionMetaEntry.class );
    doReturn( IValueMeta.TYPE_BIGNUMBER ).when( entry ).getValueType();
    RowMetaAndData row = createRowMetaAndData( new ValueMetaBigNumber( TEST_FIELD ), new BigDecimal( 1 ) );
    SourceStepField sourceField = new SourceStepField( TEST_SOURCE_STEP_NAME, TEST_FIELD );

    MetaInject.setEntryValue( entry, row, sourceField );

    verify( entry ).setValue( new BigDecimal( 1 ) );
  }
*/

  @Test
  public void convertToUpperCaseSet_null_array() {
    Set<String> actualResult = MetaInject.convertToUpperCaseSet( null );
    assertNotNull( actualResult );
    assertTrue( actualResult.isEmpty() );
  }

  @Test
  public void convertToUpperCaseSet() {
    String[] input = new String[] { "Test_Step", "test_step1" };
    Set<String> actualResult = MetaInject.convertToUpperCaseSet( input );
    Set<String> expectedResult = new HashSet<>();
    expectedResult.add( "TEST_STEP" );
    expectedResult.add( "TEST_STEP1" );
    assertEquals( expectedResult, actualResult );
  }

  @Test
  public void testGetUnavailableTargetKeys() throws Exception {
    final String targetStepName = "injectable step name";
    TargetStepAttribute unavailableTargetAttr = new TargetStepAttribute( targetStepName, "NOT_THERE", false );
    TargetStepAttribute availableTargetAttr = new TargetStepAttribute( targetStepName, "THERE", false );
    SourceStepField sourceStep = new SourceStepField( TEST_SOURCE_STEP_NAME, TEST_FIELD );

    Map<TargetStepAttribute, SourceStepField> targetMap = new HashMap<>( 2 );
    targetMap.put( unavailableTargetAttr, sourceStep );
    targetMap.put( availableTargetAttr, sourceStep );

    ITransformMeta smi = new InjectableTestStepMeta();
    PipelineMeta transMeta = mockSingleStepTransMeta( targetStepName, smi );
    Set<TargetStepAttribute> unavailable =
        MetaInject.getUnavailableTargetKeys( targetMap, transMeta, Collections.<TargetStepAttribute>emptySet() );
    assertEquals( 1, unavailable.size() );
    assertTrue( unavailable.contains( unavailableTargetAttr ) );
  }
  

  @Test
  public void testStepChangeListener() throws Exception {
    MetaInjectMeta mim = new MetaInjectMeta();
    TransformMeta sm = new TransformMeta( "testStep", mim );
    try {
      transMeta.addOrReplaceTransform( sm );
    } catch ( Exception ex ) {
      fail();
    }
  }

  private PipelineMeta mockSingleStepTransMeta( final String targetStepName, ITransformMeta smi ) {
    TransformMeta stepMeta = mock( TransformMeta.class );
    when( stepMeta.getTransform() ).thenReturn( smi );
    when( stepMeta.getName() ).thenReturn( targetStepName );
    PipelineMeta transMeta = mock( PipelineMeta.class );
    when( transMeta.getUsedTransforms() ).thenReturn( Collections.singletonList( stepMeta ) );
    return transMeta;
  }

  @InjectionSupported( localizationPrefix = "", groups = "groups" )
  private static class InjectableTestStepMeta extends BaseTransformMeta implements ITransformMeta<MetaInject, MetaInjectData> {

    @Injection( name = "THERE" )
    private String there;

    @Override
    public void setDefault() {
    }

    @Override
    public ITransform createTransform(TransformMeta transformMeta, MetaInjectData data, int copyNr, PipelineMeta pipelineMeta, Pipeline pipeline) {
      return new MetaInject(transformMeta, new MetaInjectMeta(), data, copyNr, pipelineMeta, pipeline);
    }

/*
    @Override
    public StepInterface getStep( TransformMeta stepMeta, StepDataInterface stepDataInterface, int copyNr,
        PipelineMeta transMeta, Trans trans ) {
      return null;
    }
*/


    @Override
    public MetaInjectData getTransformData() {
      return null;
    }
  }

  private static RowMetaAndData createRowMetaAndData( IValueMeta valueMeta, Object data ) {
    RowMetaAndData row = new RowMetaAndData();
    RowMeta rowMeta = new RowMeta();
    rowMeta.addValueMeta( valueMeta );
    row.setRowMeta( rowMeta );
    row.setData( new Object[] { data } );
    return row;
  }

  @Test
  public void testWriteInjectedKtrNoRepo() throws Exception {
    PowerMockito.doNothing().when( metaInject, "writeInjectedKtrToRepo", "/home/admin/injected_trans.ktr" );
    PowerMockito.doNothing().when( metaInject, "writeInjectedKtrToFs", "/home/admin/injected_trans.ktr" );
//    metaInject.setRepository( null );
    Whitebox.<String>invokeMethod( metaInject, "writeInjectedKtr", "/home/admin/injected_trans.ktr" );
    PowerMockito.verifyPrivate( metaInject, times( 0 ) ).invoke( "writeInjectedKtrToRepo",
      "/home/admin/injected_trans.ktr" );
    PowerMockito.verifyPrivate( metaInject, times( 1 ) ).invoke( "writeInjectedKtrToFs", "/home/admin/injected_trans"
      + ".ktr" );
  }

  @Test
  public void testWriteInjectedKtrWithRepo() throws Exception {
    PowerMockito.doNothing().when( metaInject, "writeInjectedKtrToRepo", "/home/admin/injected_trans.ktr" );
    PowerMockito.doNothing().when( metaInject, "writeInjectedKtrToFs", "/home/admin/injected_trans.ktr" );
//    metaInject.setRepository( repository );
    Whitebox.<String>invokeMethod( metaInject, "writeInjectedKtr", "/home/admin/injected_trans.ktr" );
    PowerMockito.verifyPrivate( metaInject, times( 1 ) ).invoke( "writeInjectedKtrToRepo",
      "/home/admin/injected_trans.ktr" );
    PowerMockito.verifyPrivate( metaInject, times( 0 ) ).invoke( "writeInjectedKtrToFs",
      "/home/admin/injected_trans.ktr" );
  }

/*
  @Test
  public void testWriteInjectedKtrToRepoSameDir() throws Exception {
    RepositoryDirectory rootDir = PowerMockito.spy( new RepositoryDirectory( null, "/" ) );
    RepositoryDirectory adminDir = PowerMockito.spy( new RepositoryDirectory( new RepositoryDirectory(
      new RepositoryDirectory( null, "/" ), "home" ), "admin" ) );
    PipelineMeta cloneMeta = PowerMockito.spy( (PipelineMeta) data.pipelineMeta.clone() );
    PowerMockito.doReturn( cloneMeta ).when( data.pipelineMeta).clone();

    PowerMockito.doReturn( adminDir ).when( repository ).createRepositoryDirectory( rootDir, "home/admin" );
    PowerMockito.doReturn( adminDir ).when( data.pipelineMeta).getRepositoryDirectory();
    PowerMockito.whenNew( RepositoryDirectory.class ).withArguments( null, "/" ).thenReturn( rootDir );

    metaInject.setRepository( repository );
    Whitebox.<String>invokeMethod( metaInject, "writeInjectedKtrToRepo", "/home/admin/injected_trans.ktr" );
    verify( repository, times( 1 ) ).findDirectory( "home/admin" );
    verify( repository, times( 1 ) ).createRepositoryDirectory( rootDir, "home/admin" );
    verify( cloneMeta, times( 1 ) ).setRepositoryDirectory( adminDir );
    verify( cloneMeta, times( 1 ) ).setObjectId( any( ObjectId.class ) );
    verify( repository, times( 1 ) ).save( cloneMeta, null, null, true );
  }
*/

/*
  @Test
  public void testWriteInjectedKtrToRepoDifferentDir() throws Exception {
    RepositoryDirectory rootDir = PowerMockito.spy( new RepositoryDirectory( null, "/" ) );
    RepositoryDirectory adminDir = PowerMockito.spy( new RepositoryDirectory( new RepositoryDirectory(
      new RepositoryDirectory( null, "/" ), "home" ), "admin" ) );
    PipelineMeta cloneMeta = PowerMockito.spy( (PipelineMeta) data.pipelineMeta.clone() );
    PowerMockito.doReturn( cloneMeta ).when( data.pipelineMeta).clone();

    PowerMockito.doReturn( adminDir ).when( repository ).createRepositoryDirectory( rootDir,
      "/home/admin" );
    PowerMockito.doReturn( adminDir ).when( data.pipelineMeta).getRepositoryDirectory();
    PowerMockito.whenNew( RepositoryDirectory.class ).withArguments( null, "/" ).thenReturn( rootDir );

    metaInject.setRepository( repository );
    Whitebox.<String>invokeMethod( metaInject, "writeInjectedKtrToRepo", "injected_trans" );
    verify( repository, times( 0 ) ).findDirectory( anyString() );
    verify( repository, times( 0 ) ).createRepositoryDirectory( any(), any() );
    verify( cloneMeta, times( 1 ) ).setRepositoryDirectory( adminDir );
    verify( cloneMeta, times( 1 ) ).setObjectId( any( ObjectId.class ) );
    verify( repository, times( 1 ) ).save( cloneMeta, null, null, true );
  }
*/
}
